问题1：#ifndef后边的一串大写字母是什么？
在 C++ 多文件项目中，头文件中 `#ifndef` 后面的一串大写字母是**头文件保护宏（Header Guard）**，用于防止头文件被重复包含。

### 作用：
防止同一个头文件被多次包含时导致的重复定义问题。

### 典型结构：
```cpp
#ifndef SOME_UNIQUE_NAME_H
#define SOME_UNIQUE_NAME_H

// 头文件内容...

#endif
```

### 命名规则：
1. **全大写字母**
2. **唯一性**（通常与文件名相关）
3. **常见格式**：`<PROJECT>_<PATH>_<FILE>_H` 或 `<FILE>_H`

### 示例：
假设头文件名为 `utils.h`，可能这样写：
```cpp
#ifndef UTILS_H
#define UTILS_H

// 函数/类声明...

#endif
```

### 现代替代方案：
C++11 后可以用 `#pragma once`（更简洁，但非标准）：
```cpp
#pragma once
// 头文件内容...
```

### 为什么需要？
- 避免重复定义导致的编译错误
- 提高编译效率（跳过已包含的文件）

注意：命名应确保项目内唯一，避免与其他头文件冲突。

----------------------------------------------------------
问题2：C++中类的定义方式？
在 C++ 中，**类（class）** 是一种用户自定义的数据类型，用于封装数据（成员变量）和操作数据的方法（成员函数）。以下是 C++ 中类的定义方式及关键要点：

---

### **1. 基本语法**
```cpp
class ClassName {
// 访问修饰符（public、private、protected）
public:  
    // 公有成员（外部可访问）
    int publicVar;
    void publicFunc();

private:  
    // 私有成员（仅类内可访问）
    int privateVar;
    void privateFunc();

protected:  
    // 受保护成员（类内及派生类可访问）
    int protectedVar;
};
```

---

### **2. 类定义的关键组成部分**
#### **(1) 成员变量（属性）**
```cpp
class Person {
private:
    std::string name; // 私有成员变量
    int age;
};
```

#### **(2) 成员函数（方法）**
- **在类内直接定义**（隐式内联）：
  ```cpp
  class Person {
  public:
      void setName(const std::string& n) { name = n; } // 直接定义
  };
  ```
- **在类外定义**（需用 `ClassName::` 限定）：
  ```cpp
  class Person {
  public:
      void setName(const std::string& n); // 声明
  };
  
  // 类外定义
  void Person::setName(const std::string& n) { 
      name = n; 
  }
  ```

#### **(3) 构造函数与析构函数**
- **构造函数**（初始化对象）：
  ```cpp
  class Person {
  public:
      Person() { std::cout << "默认构造函数\n"; } // 默认构造
      Person(std::string n, int a) : name(n), age(a) {} // 带参数构造（初始化列表）
  };
  ```
- **析构函数**（释放资源）：
  ```cpp
  ~Person() { std::cout << "析构函数调用\n"; }
  ```

#### **(4) 访问控制**
- `public`：任何代码均可访问。
- `private`：仅类内成员和友元可访问（默认）。
- `protected`：类内及派生类可访问。

---

### **3. 类的实现示例**
#### **头文件（`Person.h`）**
```cpp
#ifndef PERSON_H  // 头文件保护宏
#define PERSON_H

#include <string>

class Person {
private:
    std::string name;
    int age;

public:
    Person(); // 默认构造函数
    Person(std::string n, int a); // 带参构造函数
    void setName(std::string n);
    std::string getName() const; // const 成员函数（不修改对象）
};

#endif
```

#### **源文件（`Person.cpp`）**
```cpp
#include "Person.h"

// 构造函数定义
Person::Person() : name("Unknown"), age(0) {}

Person::Person(std::string n, int a) : name(n), age(a) {}

// 成员函数定义
void Person::setName(std::string n) { 
    name = n; 
}

std::string Person::getName() const { 
    return name; 
}
```

#### **使用类（`main.cpp`）**
```cpp
#include <iostream>
#include "Person.h"

int main() {
    Person p1;                     // 调用默认构造
    Person p2("Alice", 25);        // 调用带参构造

    p1.setName("Bob");
    std::cout << p2.getName();     // 输出: Alice
    return 0;
}
```

---

### **4. 特殊成员函数**
C++ 类会自动生成以下函数（若未显式定义）：
- **默认构造函数**（无参）
- **拷贝构造函数**（如 `Person(const Person& other)`）
- **拷贝赋值运算符**（如 `Person& operator=(const Person& other)`）
- **析构函数**
- **移动构造函数**（C++11 起）
- **移动赋值运算符**（C++11 起）

可通过 `= default` 或 `= delete` 显式控制：
```cpp
class Person {
public:
    Person() = default; // 强制生成默认构造
    Person(const Person&) = delete; // 禁止拷贝
};
```

---

### **5. 类 vs 结构体（`struct`）**
- **`class`**：默认成员为 `private`。
- **`struct`**：默认成员为 `public`（通常用于纯数据聚合）。

---

### **总结**
- 类通过 **封装** 将数据和操作绑定。
- 使用 **访问修饰符** 控制可见性。
- 构造函数/析构函数管理对象生命周期。
- 头文件声明，源文件实现，避免重复包含。

通过合理设计类，可以提高代码的可维护性和安全性。
